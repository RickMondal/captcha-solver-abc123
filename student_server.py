# student_server.py
import os
import re
import base64
import json
import uuid
import time
import shutil
import tempfile
import subprocess
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime
from pathlib import Path
from flask import Flask, request, jsonify
import requests

app = Flask(__name__)

# Configurable
SECRETS_FILE = "student_secrets.json"  # map email -> secret (create locally)
WORKDIR_BASE = Path("workspaces")
WORKDIR_BASE.mkdir(exist_ok=True)
MAX_WORKERS = 4

# Github env (must be set)
GH_TOKEN = os.environ.get("GH_TOKEN")
GH_USER = os.environ.get("GH_USER")
HOST = os.environ.get("HOST", "http://localhost:8000")
if not GH_TOKEN or not GH_USER:
    print("WARNING: GH_TOKEN or GH_USER not set. Set them in environment before running.")

executor = ThreadPoolExecutor(max_workers=MAX_WORKERS)

# Load secrets mapping (email -> secret)
def load_secrets():
    if Path(SECRETS_FILE).exists():
        with open(SECRETS_FILE, "r") as f:
            return json.load(f)
    return {}

def save_secrets(m):
    with open(SECRETS_FILE, "w") as f:
        json.dump(m, f, indent=2)

secrets_map = load_secrets()

# Helper: decode data URI attachments
def decode_data_uri(data_uri, out_path: Path):
    m = re.match(r"data:(.*?);base64,(.*)", data_uri, re.S)
    if not m:
        raise ValueError("Invalid data URI")
    b64 = m.group(2)
    data = base64.b64decode(b64)
    out_path.write_bytes(data)

# Helper: write MIT LICENSE
MIT_TEXT = """MIT License

Copyright (c) {year} {owner}

Permission is hereby granted, free of charge, to any person obtaining a copy...
(standard MIT body — insert full text here in production)
"""
def write_mit_license(path: Path, owner: str):
    path.write_text(MIT_TEXT.format(year=datetime.utcnow().year, owner=owner))

# Helper: safe run subprocess
def run(cmd, cwd=None, check=True):
    print("RUN:", cmd, "cwd=", cwd)
    return subprocess.run(cmd, cwd=cwd, check=check, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

# Minimal app generator — returns dict filename->content
def generate_minimal_app(brief: str, attachments: list):
    # This is a minimal deterministic generator.
    # Replace this function with an LLM call to create richer apps.
    index_html = f"""<!doctype html>
<html>
  <head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Task App</title></head>
  <body>
    <h1>Task App</h1>
    <div id="display-url">URL: <span id="captcha-url"></span></div>
    <div id="result">Result: <span id="captcha-result">—</span></div>
    <script>
      (async () => {{
        const params = new URLSearchParams(location.search);
        const url = params.get('url') || '{attachments[0]["name"] if attachments else ""}';
        document.getElementById('captcha-url').textContent = url;
        // Simple fetch to show image if it's an image
        try {{
          const el = document.createElement('div');
          if (url.endsWith('.png') || url.endsWith('.jpg') || url.endsWith('.jpeg')) {{
            const img = document.createElement('img'); img.src = url; img.alt = 'captcha'; img.style.maxWidth='400px';
            el.appendChild(img);
            document.body.appendChild(el);
            // Dummy "solve" after 1s
            setTimeout(()=>document.getElementById('captcha-result').textContent = 'SOLVED_PLACEHOLDER', 1000);
          }} else {{
            // show as text
            const a = document.createElement('a'); a.href = url; a.textContent = url; a.target='_blank';
            el.appendChild(a); document.body.appendChild(el);
          }}
        }} catch (e) {{ console.error(e) }}
      }})();
    </script>
  </body>
</html>"""
    readme = f"# Auto-generated app\n\nBrief: {brief}\n\nUsage: open `index.html` or deploy to GitHub Pages and use `?url=` param."
    return {"index.html": index_html, "README.md": readme}

# Create repo on GitHub via API
def github_create_repo(repo_name, description="Auto-generated by student server", private=False):
    url = "https://api.github.com/user/repos"
    headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
    payload = {"name": repo_name, "description": description, "private": private}
    r = requests.post(url, json=payload, headers=headers, timeout=10)
    r.raise_for_status()
    return r.json()

# Create pages site via API (simple attempt)
def github_enable_pages(owner, repo):
    url = f"https://api.github.com/repos/{owner}/{repo}/pages"
    headers = {"Authorization": f"token {GH_TOKEN}", "Accept": "application/vnd.github+json"}
    payload = {"source": {"branch": "main", "path": "/"}}
    r = requests.post(url, json=payload, headers=headers, timeout=10)
    # API returns 201 on success. if already enabled, may 409 or 200 depending. Return r
    return r

# Poll pages_url until 200 or timeout
def wait_for_pages(pages_url, timeout=300, poll_interval=3):
    end = time.time() + timeout
    while time.time() < end:
        try:
            r = requests.get(pages_url, timeout=10)
            if r.status_code == 200:
                return True
        except Exception:
            pass
        time.sleep(poll_interval)
    return False

# Exponential backoff notify
def notify_evaluation_url(eval_url, payload, max_attempts=8):
    delay = 1
    headers = {"Content-Type": "application/json"}
    for attempt in range(max_attempts):
        try:
            r = requests.post(eval_url, json=payload, headers=headers, timeout=10)
            status = r.status_code
            if status == 200:
                print("Evaluation endpoint acknowledged (200).")
                return True
            print(f"Evaluation endpoint returned status {status}, attempt {attempt+1}")
        except Exception as e:
            print("Notify exception:", e)
        time.sleep(delay)
        delay = min(delay * 2, 60)
    print("Notify failed after attempts.")
    return False

# Core build pipeline (run in background)
def process_task(task_json):
    try:
        print("Processing task:", task_json.get("task"))
        email = task_json["email"]
        task_id = task_json["task"]
        round_no = int(task_json.get("round", 1))
        nonce = task_json.get("nonce")
        brief = task_json.get("brief", "")
        attachments = task_json.get("attachments", [])
        evaluation_url = task_json.get("evaluation_url")

        ws = Path(tempfile.mkdtemp(prefix=f"task-{task_id}-"))
        print("Workspace:", ws)

        # decode attachments
        for att in attachments:
            name = att["name"]
            uri = att["url"]
            out = ws / name
            decode_data_uri(uri, out)
            print("Wrote attachment:", out)

        # generate files (LLM hook could be here)
        files = generate_minimal_app(brief, attachments)
        for fname, content in files.items():
            (ws / fname).write_text(content, encoding="utf-8")

        # add LICENSE
        write_mit_license(ws / "LICENSE", owner=GH_USER)

        # git init & commit
        run(["git", "init"], cwd=str(ws))
        run(["git", "config", "user.email", f"{email}"], cwd=str(ws))
        run(["git", "config", "user.name", GH_USER], cwd=str(ws))
        run(["git", "add", "--all"], cwd=str(ws))
        run(["git", "commit", "-m", f"Initial commit for {task_id} round {round_no}"], cwd=str(ws))

        # create remote repository via API
        # ensure unique name: taskid + short uuid
        repo_name = f"{task_id}-{uuid.uuid4().hex[:6]}"
        ghresp = github_create_repo(repo_name, description=f"Task {task_id} round {round_no}", private=False)
        repo_url = ghresp["html_url"]
        remote_url = f"https://{GH_TOKEN}@github.com/{GH_USER}/{repo_name}.git"

        # add remote and push
        run(["git", "remote", "add", "origin", remote_url], cwd=str(ws))
        run(["git", "branch", "-M", "main"], cwd=str(ws))
        run(["git", "push", "-u", "origin", "main"], cwd=str(ws))

        # get commit sha
        r = run(["git", "rev-parse", "HEAD"], cwd=str(ws))
        commit_sha = r.stdout.strip()

        # enable pages
        pages_resp = github_enable_pages(GH_USER, repo_name)
        print("Pages API response:", pages_resp.status_code if pages_resp is not None else None)
        pages_url = f"https://{GH_USER}.github.io/{repo_name}/"

        # wait for pages
        ok = wait_for_pages(pages_url, timeout=180, poll_interval=2)
        if not ok:
            print(f"Pages URL {pages_url} didn't respond 200 in time")

        # prepare evaluation payload
        payload = {
            "email": email,
            "task": task_id,
            "round": round_no,
            "nonce": nonce,
            "repo_url": repo_url,
            "commit_sha": commit_sha,
            "pages_url": pages_url
        }

        # notify evaluation_url
        if evaluation_url:
            notify_evaluation_url(evaluation_url, payload)

        print("Task processing finished:", task_id, repo_url)
        # OPTIONAL: cleanup workspace
        # shutil.rmtree(ws)

    except Exception as e:
        print("Error processing task:", e)


@app.route("/api/task", methods=["POST"])
def api_task():
    try:
        data = request.get_json(force=True)
    except Exception:
        return jsonify({"error":"invalid json"}), 400

    # minimal validation
    required = ["email", "secret", "task", "round", "nonce", "brief", "evaluation_url"]
    for k in required:
        if k not in data:
            return jsonify({"error": f"missing {k}"}), 400

    email = data["email"]
    secret = data["secret"]
    stored = secrets_map.get(email)
    if stored is None or stored != secret:
        return jsonify({"error":"invalid secret"}), 400

    # Immediately ack with 200 and start processing in background
    executor.submit(process_task, data)
    return jsonify({"status":"ok"}), 200

# Simple endpoint to add a secret locally (not for production)
@app.route("/admin/add_secret", methods=["POST"])
def add_secret():
    data = request.get_json(force=True)
    email = data.get("email")
    secret = data.get("secret")
    if not email or not secret:
        return jsonify({"error":"need email & secret"}), 400
    secrets_map[email] = secret
    save_secrets(secrets_map)
    return jsonify({"status":"saved"}), 200

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 8000))
    app.run(host="0.0.0.0", port=port)
